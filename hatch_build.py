# pyright: reportImplicitOverride=none
# pyright: reportUnknownArgumentType=none
# pyright: reportUnknownMemberType=none
# pyright: reportUnknownVariableType=none
# ruff: noqa: PLR2004

import ctypes as ct
import datetime as dt
from pathlib import Path
from textwrap import indent
from typing import Any, Literal, TypeAlias

from hatchling.builders.hooks.plugin.interface import BuildHookInterface
from hatchling.builders.wheel import WheelBuilderConfig

TAB = " " * 4
NEWLINE = "\n"
MAX_INLINE_LENGTH = 60


def _pyfmt(v: Any, /) -> str:  # noqa: C901, PLR0911, PLR0912
    """Convert primitive value to Python source code representation."""
    if isinstance(v, str):
        if '"' in v and "'" in v:
            return f'"""{v}"""'
        return f"'{v}'" if '"' in v else f'"{v}"'
    if isinstance(v, int | float | complex) or v is None:
        return str(v)
    if isinstance(v, type):
        return v.__qualname__
    if isinstance(v, tuple):
        if not v:
            return "()"
        str_items = [_pyfmt(item) for item in v]
        out_inline = ", ".join(str_items)
        if len(v) == 1:
            return f"({out_inline},)"
        if len(out_inline) < MAX_INLINE_LENGTH and NEWLINE not in out_inline:
            return out_inline
        return NEWLINE.join(["(", *[f"{indent(v, TAB)}," for v in str_items], ")"])
    if isinstance(v, list):
        if not v:
            return "[]"
        str_items = [_pyfmt(item) for item in v]
        out_inline = "[" + ", ".join(str_items) + "]"
        if len(out_inline) < MAX_INLINE_LENGTH and NEWLINE not in out_inline:
            return out_inline
        return NEWLINE.join(["[", *[f"{indent(v, TAB)}," for v in str_items], "]"])
    if isinstance(v, dict):
        if not v:
            return "{}"
        str_items = [f"{_pyfmt(k)}: {_pyfmt(v)}" for k, v in v.items()]
        out_inline = "{" + ", ".join(str_items) + "}"
        if len(out_inline) < MAX_INLINE_LENGTH and NEWLINE not in out_inline:
            return out_inline
        return NEWLINE.join(["{", *(f"{indent(kv, TAB)}," for kv in str_items), "}"])
    raise TypeError(type(v).__name__)


_TimeSpec: TypeAlias = Literal[
    "auto",
    "hours",
    "minutes",
    "seconds",
    "milliseconds",
    "microseconds",
]


def _zulu_now(unit: _TimeSpec = "seconds", /) -> str:
    # ISO 8601 timestamp in Zulu (a.k.a. UTC and GMT+00:00) format
    # https://wikipedia.org/wiki/Military_time_zone
    return dt.datetime.now(tz=dt.UTC).isoformat("T", unit).replace("+00:00", "Z")


def _build_consts_module(generator: str, /, **consts: Any) -> str:
    now = _zulu_now()
    lines = [
        f"# @generated by {generator} on {now}",
        "# !!! DO NOT EDIT !!!",
        "",
        "from typing import Final",
        "",
        f"__all__ = {_pyfmt(sorted(consts.keys()))}",
        "",
        *[f"{name}: Final = {_pyfmt(value)}" for name, value in consts.items()],
        "",  # trailing newline
    ]
    return NEWLINE.join(lines)


class CustomBuildHook(BuildHookInterface[WheelBuilderConfig]):
    generated: list[Path]  # pyright: ignore[reportUninitializedInstanceVariable]

    def initialize(self, /, version: str, build_data: dict[str, Any]) -> None:
        # `version` will either be "editable" or "standard"
        # `build_data` will has:
        # `infer_tag: bool`
        self.generated = []

        consts_path = Path(self.root) / "optype" / "_constants.py"
        assert consts_path.parent.is_dir(), consts_path.parent

        self.generated.append(consts_path)
        for path in self.generated:
            build_data["artifacts"].append(str(path.relative_to(self.root)))

        metadata = self.metadata.core_raw_metadata
        package_name = metadata["name"]
        package_version = metadata["version"]
        sizeof_ssize_t = ct.sizeof(ct.c_ssize_t)

        consts_src = _build_consts_module(
            f"{package_name} {package_version}",
            # project metadata
            NAME=package_name,
            DESCRIPTION=metadata["description"],
            AUTHOR=metadata["authors"][0]["name"],
            LICENSE=metadata["license"],
            VERSION=package_version,
            VERSION_MAJOR=int(package_version.split(".", 1)[0]),
            VERSION_MINOR=int(package_version.split(".", 2)[1]),
            VERSION_PATCH=int(package_version.split(".", 3)[2]),
            # C info
            SIZEOF_BYTE=ct.sizeof(ct.c_byte),
            SIZEOF_SHORT=ct.sizeof(ct.c_short),
            SIZEOF_INT=ct.sizeof(ct.c_int),
            SIZEOF_LONG=ct.sizeof(ct.c_long),
            SIZEOF_SSIZE_T=sizeof_ssize_t,
            SIZEOF_LONGLONG=ct.sizeof(ct.c_longlong),
            SIZEOF_FLOAT=ct.sizeof(ct.c_float),
            SIZEOF_DOUBLE=ct.sizeof(ct.c_double),
            SIZEOF_LONGDOUBLE=ct.sizeof(ct.c_longdouble),
            IS_16BIT=sizeof_ssize_t == 2,
            IS_32BIT=sizeof_ssize_t == 4,
            IS_64BIT=sizeof_ssize_t == 8,
            # build info
            BUILD_ROOT=self.root,
            IS_WHEEL=self.target_name == "wheel",
            IS_SDIST=self.target_name == "sdist",
            IS_EDITABLE=version == "editable",
        )
        consts_path.write_text(consts_src, encoding="utf-8", newline=NEWLINE)

        return super().initialize(version, build_data)
